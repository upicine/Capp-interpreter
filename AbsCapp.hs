

module AbsCapp where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
data Program = Program [Decl]
  deriving (Eq, Ord, Show, Read)

data Block = BDeclBlock [Decl] [Stmt]
  deriving (Eq, Ord, Show, Read)

data Stmt
    = SBlock Block
    | SWhile Expr Block
    | SFor Ident Expr Expr Block
    | SAss Ident Expr
    | SIncr Ident
    | SDecr Ident
    | SAssOp Ident OpAss Expr
    | SIf Expr Block
    | SIfEl Expr Block Block
    | SReturnE Expr
    | SCont
    | SBreak
    | SPrint Expr
    | SExpr Expr
  deriving (Eq, Ord, Show, Read)

data OpAss = OAssP | OAssM
  deriving (Eq, Ord, Show, Read)

data Decl
    = DefVar Type [Ident]
    | DefVarExp Type Ident Expr
    | DefFunc Type Ident [Arg] Block
  deriving (Eq, Ord, Show, Read)

data Arg = Arg Type Ident
  deriving (Eq, Ord, Show, Read)

data Type = Int | Str | Bool
  deriving (Eq, Ord, Show, Read)

data Expr
    = EStr String
    | EVar Ident
    | EInt Integer
    | ETrue
    | EFalse
    | EApp Ident [Expr]
    | EUnar OpUnar Expr
    | EMul Expr OpMul Expr
    | EAdd Expr OpAdd Expr
    | ECmp Expr OpCmp Expr
    | ELog Expr OpLog Expr
  deriving (Eq, Ord, Show, Read)

data OpMul = OMod | OMul | ODiv
  deriving (Eq, Ord, Show, Read)

data OpAdd = OPlus | OMinus
  deriving (Eq, Ord, Show, Read)

data OpCmp = OLt | OGt | OLte | OGte | OEq
  deriving (Eq, Ord, Show, Read)

data OpLog = OAnd | OOr
  deriving (Eq, Ord, Show, Read)

data OpUnar = ONot
  deriving (Eq, Ord, Show, Read)

